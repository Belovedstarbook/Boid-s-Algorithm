<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boid's Algorithm - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            text-align: center;
        }

        #spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<script type="importmap">
    {
        "imports": {
          "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
        }
    }
    </script>

<body>

    <!-- Loading Icon -->
    <div id="loading">
        <div id="spinner"></div>
        Loading...
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Hide the loading spinner
        const hideLoading = () => {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
        };

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false; // Disable panning in screen space
        controls.minDistance = 10; // Minimum zoom distance
        controls.maxDistance = 100; // Maximum zoom distance

        // Boid parameters
        const numBoids = 100;
        const boids = [];
        const boidSpeed = 0.1;
        const perceptionRadius = 5;

        // Create boids
        const boidGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const boidMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

        for (let i = 0; i < numBoids; i++) {
            const boid = new THREE.Mesh(boidGeometry, boidMaterial);
            boid.position.set(
                Math.random() * 50 - 25,
                Math.random() * 50 - 25,
                Math.random() * 50 - 25
            );
            boid.velocity = new THREE.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize().multiplyScalar(boidSpeed);
            boids.push(boid);
            scene.add(boid);
        }

        // Boid behavior functions
        function align(boid, neighbors) {
            const alignment = new THREE.Vector3();
            neighbors.forEach(neighbor => alignment.add(neighbor.velocity));
            if (neighbors.length > 0) alignment.divideScalar(neighbors.length).normalize();
            return alignment;
        }

        function cohesion(boid, neighbors) {
            const center = new THREE.Vector3();
            neighbors.forEach(neighbor => center.add(neighbor.position));
            if (neighbors.length > 0) center.divideScalar(neighbors.length).sub(boid.position).normalize();
            return center;
        }

        function separation(boid, neighbors) {
            const separation = new THREE.Vector3();
            neighbors.forEach(neighbor => {
                const diff = new THREE.Vector3().subVectors(boid.position, neighbor.position);
                if (diff.length() > 0) separation.add(diff.normalize().divideScalar(diff.length()));
            });
            return separation;
        }

        // Update boids
        function updateBoids() {
            boids.forEach(boid => {
                // Find neighbors
                const neighbors = boids.filter(other => {
                    return other !== boid && boid.position.distanceTo(other.position) < perceptionRadius;
                });

                // Apply behaviors
                const alignment = align(boid, neighbors).multiplyScalar(0.5);
                const cohesionForce = cohesion(boid, neighbors).multiplyScalar(0.5);
                const separationForce = separation(boid, neighbors).multiplyScalar(1.5);

                // Update velocity
                boid.velocity.add(alignment).add(cohesionForce).add(separationForce).normalize().multiplyScalar(boidSpeed);

                // Update position
                boid.position.add(boid.velocity);

                // Wrap around edges
                ['x', 'y', 'z'].forEach(axis => {
                    if (boid.position[axis] > 25) boid.position[axis] = -25;
                    if (boid.position[axis] < -25) boid.position[axis] = 25;
                });
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateBoids();
            controls.update(); // Update OrbitControls
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Camera position
        camera.position.set(0, 0, 50);

        // Start animation
        animate();


        // Hide the loading spinner after the scene is initialized
        hideLoading();
    </script>
</body>

</html>